import unittest
from unittest.mock import MagicMock, patch, call
import traceback

class TestReadData(unittest.TestCase):

    @patch('your_module.DataTypeConvert')  # 替换为实际模块路径
    @patch('your_module.globals')
    def test_read_data_success(self, mock_globals, mock_data_type_convert):
        # 模拟依赖项
        mock_logger = MagicMock()
        mock_spark = MagicMock()
        mock_spark.read.jdbc.return_value.dtypes = [("col1", "int"), ("col2", "string")]
        
        # 模拟配置
        config = {
            "dbConfig": "DB2Config",
            "query": "SELECT * FROM table"
        }
        
        # 模拟连接类
        mock_conn_class = MagicMock()
        mock_conn_instance = mock_conn_class.return_value
        mock_conn_instance.jdbc_connection.return_value = (
            {"user": "test", "password": "pass"},
            "jdbc:db2://host:port/db"
        )
        mock_globals.return_value = {
            "DB2Config": {"class": mock_conn_class}
        }
        
        # 模拟类型转换
        mock_convert_instance = mock_data_type_convert.return_value
        mock_convert_instance.get_target_column_type.side_effect = ["INTEGER", "VARCHAR"]
        
        # 调用被测方法
        from your_module import YourClass  # 替换为实际模块路径
        result = YourClass().read_data(
            logger=mock_logger,
            spark=mock_spark,
            config=config,
            collectionName="test_collection",
            schema=None
        )
        
        # 验证日志调用
        mock_logger.info.assert_has_calls([
            call("Starting data extraction from DB2..."),
            call("Executing query: SELECT * FROM table")
        ])
        
        # 验证连接调用
        mock_conn_class.assert_called_once()
        mock_conn_instance.jdbc_connection.assert_called_once_with("DB2Config")
        
        # 验证Spark调用
        mock_spark.read.jdbc.assert_called_once_with(
            url="jdbc:db2://host:port/db",
            table="(SELECT * FROM table) AS subquery",
            properties={"user": "test", "password": "pass"}
        )
        
        # 验证类型转换
        result.select.assert_called_once()
        select_args = result.select.call_args[0][0]
        self.assertEqual(len(select_args), 2)
        self.assertEqual(str(select_args[0]), "col(col1).cast(INTEGER)")
        self.assertEqual(str(select_args[1]), "col(col2).cast(VARCHAR)")

    @patch('your_module.DataTypeConvert')
    @patch('your_module.globals')
    def test_read_data_failure(self, mock_globals, mock_data_type_convert):
        # 模拟依赖项
        mock_logger = MagicMock()
        mock_spark = MagicMock()
        mock_spark.read.jdbc.side_effect = Exception("DB connection failed")
        
        # 模拟配置
        config = {
            "dbConfig": "DB2Config",
            "query": "SELECT * FROM table"
        }
        
        # 模拟连接类
        mock_conn_class = MagicMock()
        mock_conn_instance = mock_conn_class.return_value
        mock_conn_instance.jdbc_connection.return_value = (
            {"user": "test", "password": "pass"},
            "jdbc:db2://host:port/db"
        )
        mock_globals.return_value = {
            "DB2Config": {"class": mock_conn_class}
        }
        
        # 调用被测方法并验证异常
        from your_module import YourClass  # 替换为实际模块路径
        with self.assertRaises(Exception):
            YourClass().read_data(
                logger=mock_logger,
                spark=mock_spark,
                config=config,
                collectionName="test_collection",
                schema=None
            )
        
        # 验证错误日志
        mock_logger.error.assert_has_calls([
            call("Error details: (e)"),
            call(traceback.format_exc())
        ])